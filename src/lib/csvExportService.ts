// src/lib/csvExportService.ts
import Papa from 'papaparse';

export interface ExportConfig {
  filename: string;
  data: any[];
  fields?: string[];
  includeMetadata?: boolean;
  dateFormat?: 'iso' | 'readable';
}

export interface ExportMetadata {
  exportDate: string;
  exportedBy: string;
  recordCount: number;
  filters?: Record<string, any>;
}

/**
 * CSV Export Service
 * Handles exporting data to CSV format with configurable fields and metadata
 */
export class CSVExportService {
  /**
   * Export data to CSV and trigger download
   */
  static exportToCSV(config: ExportConfig): void {
    const { filename, data, fields, includeMetadata = true, dateFormat = 'readable' } = config;

    if (!data || data.length === 0) {
      throw new Error('No data to export');
    }

    // Prepare data with formatted fields
    const formattedData = this.formatDataForExport(data, dateFormat);

    // Generate CSV content
    const csv = Papa.unparse(formattedData, {
      columns: fields,
      header: true,
    });

    // Add metadata header if requested
    let csvContent = csv;
    if (includeMetadata) {
      const metadata = this.generateMetadataHeader(data.length);
      csvContent = metadata + '\n\n' + csv;
    }

    // Trigger download
    this.downloadCSV(csvContent, filename);
  }

  /**
   * Format data for export (handle dates, nested objects, etc.)
   */
  private static formatDataForExport(data: any[], dateFormat: 'iso' | 'readable'): any[] {
    return data.map(row => {
      const formattedRow: Record<string, any> = {};
      
      Object.keys(row).forEach(key => {
        const value = row[key];
        
        // Handle dates
        if (value instanceof Date) {
          formattedRow[key] = dateFormat === 'iso' 
            ? value.toISOString() 
            : this.formatReadableDate(value);
        }
        // Handle string dates
        else if (typeof value === 'string' && this.isDateString(value)) {
          const date = new Date(value);
          formattedRow[key] = dateFormat === 'iso' 
            ? date.toISOString() 
            : this.formatReadableDate(date);
        }
        // Handle boolean values
        else if (typeof value === 'boolean') {
          formattedRow[key] = value ? 'Yes' : 'No';
        }
        // Handle arrays
        else if (Array.isArray(value)) {
          formattedRow[key] = value.join(', ');
        }
        // Handle nested objects
        else if (typeof value === 'object' && value !== null) {
          formattedRow[key] = JSON.stringify(value);
        }
        // Handle null/undefined
        else if (value === null || value === undefined) {
          formattedRow[key] = '';
        }
        // Handle everything else
        else {
          formattedRow[key] = value;
        }
      });
      
      return formattedRow;
    });
  }

  /**
   * Generate metadata header for CSV
   */
  private static generateMetadataHeader(recordCount: number): string {
    const now = new Date();
    const metadata = [
      `Export Date: ${this.formatReadableDate(now)}`,
      `Record Count: ${recordCount}`,
      `Generated by: GBP Copilot Platform`,
    ];
    
    return metadata.map(line => `# ${line}`).join('\n');
  }

  /**
   * Format date to readable string
   */
  private static formatReadableDate(date: Date): string {
    return date.toLocaleString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      timeZoneName: 'short'
    });
  }

  /**
   * Check if string is a valid date string
   */
  private static isDateString(value: string): boolean {
    // Check for ISO format or common date formats
    const datePattern = /^\d{4}-\d{2}-\d{2}|^\d{2}\/\d{2}\/\d{4}/;
    if (!datePattern.test(value)) return false;
    
    const date = new Date(value);
    return !isNaN(date.getTime());
  }

  /**
   * Trigger CSV file download
   */
  private static downloadCSV(content: string, filename: string): void {
    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    
    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', this.sanitizeFilename(filename));
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  }

  /**
   * Sanitize filename and add .csv extension
   */
  private static sanitizeFilename(filename: string): string {
    // Remove invalid filename characters
    let sanitized = filename.replace(/[^a-z0-9_\-]/gi, '_');
    
    // Add timestamp
    const timestamp = new Date().toISOString().split('T')[0];
    sanitized = `${sanitized}_${timestamp}`;
    
    // Ensure .csv extension
    if (!sanitized.toLowerCase().endsWith('.csv')) {
      sanitized += '.csv';
    }
    
    return sanitized;
  }

  /**
   * Export customers to CSV
   */
  static exportCustomers(customers: any[]): void {
    const fields = [
      'name',
      'email',
      'organization_name',
      'status',
      'products',
      'created_at',
      'updated_at'
    ];

    const formattedCustomers = customers.map(customer => ({
      name: customer.name || '',
      email: customer.email || '',
      organization_name: customer.organization?.name || 'N/A',
      status: customer.status || 'active',
      products: customer.organization?.products?.map((p: any) => p.name).join(', ') || 'None',
      created_at: customer.created_at,
      updated_at: customer.updated_at
    }));

    this.exportToCSV({
      filename: 'customers_export',
      data: formattedCustomers,
      fields,
    });
  }

  /**
   * Export users to CSV
   */
  static exportUsers(users: any[]): void {
    const fields = [
      'name',
      'email',
      'role',
      'organization_name',
      'status',
      'last_sign_in',
      'created_at'
    ];

    const formattedUsers = users.map(user => ({
      name: user.name || '',
      email: user.email || '',
      role: user.role || 'user',
      organization_name: user.organization?.name || 'N/A',
      status: user.status || 'active',
      last_sign_in: user.last_sign_in_at || 'Never',
      created_at: user.created_at
    }));

    this.exportToCSV({
      filename: 'users_export',
      data: formattedUsers,
      fields,
    });
  }

  /**
   * Export organizations to CSV
   */
  static exportOrganizations(organizations: any[]): void {
    const fields = [
      'name',
      'type',
      'plan',
      'status',
      'products',
      'user_count',
      'location_count',
      'created_at'
    ];

    const formattedOrgs = organizations.map(org => ({
      name: org.name || '',
      type: org.type || 'customer',
      plan: org.plan || 'free',
      status: org.status || 'active',
      products: org.products?.map((p: any) => p.name).join(', ') || 'None',
      user_count: org.user_count || 0,
      location_count: org.location_count || 0,
      created_at: org.created_at
    }));

    this.exportToCSV({
      filename: 'organizations_export',
      data: formattedOrgs,
      fields,
    });
  }
}